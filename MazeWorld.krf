(in-microtheory MazeWorldMt) 
(genlMt MazeWorldMt HTNPlanner)
(genlMt Session-ReasonerPlanMt MazeWorldMt)

;;; axiom vocab

(isa hasAgent UnaryPredicate)
(arity hasAgent 1)
(arg1Isa hasAgent mazeBlock)
(comment hasAgent "(hasAgent ?x) means the agent is at mazeBlock ?x.")

(isa keyCount UnaryPredicate)
(arity keyCount 1)
(arg1Isa keyCount NonNegativeInteger)
(comment keyCount "(keyCount ?x) means the agent has ?x keys.")

(isa coordinate TernaryPredicate)
(arity coordinate 3)
(arg1Isa coordinate mazeBlock)
(arg2Isa coordinate NonNegativeInteger)
(arg3Isa coordinate NonNegativeInteger)
(comment coordinate "(coordinate ?x ?y ?z) means the mazeBlock ?x is located at (?y,?z).")

(isa isWalk UnaryPredicate)
(arity isWalk 1)
(arg1Isa isWalk mazeBlock)
(comment isWalk "(isWalk ?x) means mazeBlock ?x is traversible by the agent.")

(isa hasKey UnaryPredicate)
(arity hasKey 1)
(arg1Isa hasKey mazeBlock)
(comment hasKey "(hasKey ?x) means mazeBlock ?x is contains a key for the door.")

(isa isExit UnaryPredicate)
(arity isExit 1)
(arg1Isa isExit mazeBlock)
(comment isExit "(isExit ?x) means mazeBlock ?x is the exit mazeBlock.")

(isa finalPath UnaryPredicate)
(arity finalPath 1)
(arg1Isa finalPath List)
(comment finalPath "(finalPath ?x) ?x is an ordered list of mazeBlocks leading through the maze to the exit.")

;;; primitives

;(isa execMove SimpleActionPredicate)
;(arity execMove 2)
;(arg1Isa execMove mazeBlock)
;(arg1Isa execMove mazeBlock)
;(comment execMove "(execMove ?sq1 ?sq2) takes the agent from ?sq1 to ?sq2")

;(isa doFinalize SimpleActionPredicate)
;(arity doFinalize 1)
;(arg1Isa doFinalize List)
;(comment doFinalize "(doFinalize ?l) finalizes l as the path.")

;(isa removeKey SimpleActionPredicate)
;(arity removeKey 1)
;(arg1Isa removeKey mazeBlock)
;(comment removeKey "(removeKey ?x) removes the key from mazeBlock ?x.")

;(isa removeKeyCount SimpleActionPredicate)
;(arity removeKeyCount 0)
;(comment removeKeyCount "(removeKeyCount ?x) deletes the current count of keys")

;(isa addKeyCount SimpleActionPredicate)
;(arity addKeyCount 0)
;(comment addKeyCount "(addKeyCount ?x) add the current count of keys")

;;; Horn Clauses
(<== (connected ?blockA ?blockB)
	(isWalk ?blockA)
	(isWalk ?blockB)
	(coordinate ?blockA ?xA ?yA)
	(coordinate ?blockB ?xB ?yA)
	(evaluate ?x (DifferenceFn ?xA ?xB))
	(evaluate ?y (AbsoluteValueFn ?x))
	(equals ?y 1))

(<== (connected ?blockA ?blockB)
	(isWalk ?blockA)
	(isWalk ?blockB)
	(coordinate ?blockA ?xA ?yA)
	(coordinate ?blockB ?xA ?yB)
	(evaluate ?x (DifferenceFn ?yA ?yB))
	(evaluate ?y (AbsoluteValueFn ?x))
	(equals ?y 1))

(<== (isDeadEnd ?block)
    (equals (TheClosedRetrievalSetOf (connected ?block ?x)) 1))

(<== (solutionReached)
    (totalKeyNumber ?x)
    (keyCount ?y)
    (equals ?x ?y)
    (isExit ?exitBlock)
    (hasAgent ?exitBlock))

;;; Preference rules:
;(<== (preferInContext (mazeAct ?actList) ?seq1 ?seq2)
;	(evaluate ?x (CountFn ?seq1 ?actList)) 
;	(evaluate ?y (CountFn ?seq2 ?actList))
;	(greaterThan ?y ?x))

;(<== (preferInContext (mazeAct ?actList) ?seq1 ?seq2)
;	(subexpressionMatching (execMove ?a ?b) ?seq1 ?action)
;	(subexpressionMatching (execMove ?c ?d) ?seq2 ?action2)
;	(evaluate ?x (CountFn ?b ?actList)) 
;	(evaluate ?y (CountFn ?d ?actList))
;	(greaterThan ?y ?x))

;(<== (preferInContext (mazeAct ?actList) ?seq1 ?seq2)
;	(subexpressionMatching (removeKey ?x) ?seq1 ?action))

;(<== (preferInContext (mazeAct ?actList) ?seq1 ?seq2)
;	(subexpressionMatching (doAssert ?x) ?seq1 ?action))

;(<== (preferInContext (mazeAct ?actList) ?seq1 ?seq2)
;	(containsPattern (connected ?a ?b) ?seq1)
;	(containsPattern (connected ?c ?d) ?seq2)
;	(evaluate ?x (CountFn ?b ?actList)) 
;	(evaluate ?y (CountFn ?d ?actList))
;	(greaterThan ?y ?x))

;(<== (preferInContext (mazeAct ?actList) ?seq1 ?seq2)
;	(containsPattern (hasKey ?x) ?seq1))

;(<== (preferInContext (mazeAct ?actList) ?seq1 ?seq2)
;	(containsPattern (isExit ?x) ?seq1))

;;; preconditions for primitives

;(preconditionFor-Props
;	(and 	(hasAgent ?x)
;			(connected ?x ?y))
;	(execMove ?x ?y))

;;; effects of primitives

;(effectOfAction-Props
;	(execMove ?x ?y)
;	(and 	(hasAgent ?y)
;       	(not (hasAgent ?x))))

;(effectOfAction-Props
;	(doFinalize ?l)
;	(finalPath ?l))

;(effectOfAction-Props
;	(removeKey ?x)
;	(not	(hasKey ?x)))

;(effectOfAction-Props
;	(removeKeyCount ?x)
;	(not 	(keyCount ?x)))

;(effectOfAction-Props
;	(addKeyCount ?x)
;	(keyCount ?x))

;(effectOfAction-Props
;	(doAssert ?fact)
;	 ?fact)

;;; complex actions

;(isa incrementKeys ComplexActionPredicate)
;(arity incrementKeys 0)
;(comment incrementKeys "(incrementKeys) records the agent as having 1 more key than before.")

(isa mazeAct ComplexActionPredicate)
(arity mazeAct 1)
(arg1Isa mazeAct List)
(comment mazeAct "(mazeAct ?l) recursively solves the maze in the current context and eventually saves ?l, the list of actions it took to solve the maze.")

(isa beginRecursion ComplexActionPredicate)
(arity beginRecursion 0)
(comment beginRecursion "(beginRecursion) calls (mazeAct (TheList)).")


;;; complex action real definition

;grab a key from the mazeBlock you're in
(preconditionForMethod
	(and	(uninferredSentence (solutionReached))
		(hasAgent ?x)
		(hasKey ?x)
		(keyCount ?y)
		(evaluate ?newList (JoinListsFn ?actList (TheList ?x))))
	(methodForAction
		(mazeAct ?actList)
		(actionSequence
			(TheList
				(evaluate ?z (PlusFn ?y 1))
				(untell (keyCount ?y))
				(tell (keyCount ?z))
				(untell (hasKey ?x))
				(mazeAct ?newList)))))

;move to an adjacent mazeBlock, and don't backtrack
(preconditionForMethod
	(and	(uninferredSentence (hasKey ?x))
		(uninferredSentence (solutionReached))
		(hasAgent ?x)
		(connected ?x ?y)
		(evaluate ?last (LastInListFn ?actList))
		(different ?y ?last)
		(evaluate ?newList (JoinListsFn ?actList (TheList ?x))))
	(methodForAction
		(mazeAct ?actList)
		(actionSequence
			(TheList
				(tell (hasAgent ?y))
				(untell (hasAgent ?x))
				(mazeAct ?newList)))))

;move to an adjacent mazeBlock and backtrack because you're in a dead end
(preconditionForMethod
	(and	(uninferredSentence (hasKey ?x))
		(uninferredSentence (solutionReached))
		(hasAgent ?x)
		(connected ?x ?y)
		(isDeadEnd ?x)
		(evaluate ?newList (JoinListsFn ?actList (TheList ?x))))
	(methodForAction
		(mazeAct ?actList)
		(actionSequence
			(TheList
				(tell (hasAgent ?y))
				(untell (hasAgent ?x))
				(mazeAct ?newList)))))

;If all goals are satisfied, at end of maze, do nothing
(preconditionForMethod
	(solutionReached)
	(methodForAction
		(mazeAct ?actList)
		(actionSequence
			(TheList
				(ist-Information aMAZEingMt (tell (finalPath ?actList)))))))

;to start everything, we need something with no preconditions
(preconditionForMethod
	(true)
	(methodForAction
		(beginRecursion)
		(actionSequence
			(TheList
				(mazeAct (TheList))))))